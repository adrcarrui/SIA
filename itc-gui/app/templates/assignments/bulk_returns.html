{% extends "base.html" %}

{% block content %}
<div class="container py-3">
  <h4 class="mb-3">Return devices</h4>

  <form method="post" id="bulk-return-form">
    {% if csrf_token is defined %}
      {{ csrf_token() }}
    {% endif %}

    <!-- BotÃ³n NFC + estado -->
    <div class="mb-3 d-flex align-items-center gap-3">
      <button type="button" id="btn-read-uid" class="btn btn-primary btn-sm" disabled>
        <span id="btn-read-icon">ðŸ“¡</span>
        <span>Reading cardsâ€¦</span>
      </button>
      <small id="uid-status" class="text-muted">
        Approach cards to the reader. New cards will be added automatically.
      </small>
    </div>

    <!-- Tabla de devices -->
    <div class="table-responsive mb-3">
      <table class="table table-sm align-middle mb-0">
        <thead>
          <tr>
            <th>#</th>
            <th>Device name</th>
            <th>UID</th>
            <th>Course</th>
            <th>End date</th>
            <th>Overdue days</th>
            <th class="text-end">Actions</th>
          </tr>
        </thead>
        <tbody id="devices-table-body">
          <!-- Filas generadas por JS al leer tarjetas -->
        </tbody>
      </table>
    </div>

    <div class="d-flex justify-content-between mt-3">
      <a href="{{ url_for('main.index') }}" class="btn btn-secondary">
        Cancel
      </a>
      <button type="submit" class="btn btn-primary" id="submit-btn">
        Return selected cards
      </button>
    </div>
  </form>
</div>

<script>
document.addEventListener("DOMContentLoaded", function () {
  console.log("assignments bulk RETURN NFC JS cargado (auto-poll)");

  const btn    = document.getElementById("btn-read-uid");
  const status = document.getElementById("uid-status");
  const icon   = document.getElementById("btn-read-icon");
  const tbody  = document.getElementById("devices-table-body");
  const submit = document.getElementById("submit-btn");

  if (!btn || !status || !icon || !tbody || !submit) {
    console.warn("Elementos NFC (assignments bulk return) no encontrados en el DOM");
    return;
  }

  // Para evitar duplicados de UID
  const addedUids = new Set();
  let polling = true;
  const POLL_DELAY_MS = 1000;  // 1s entre lecturas

  function refreshSubmitState() {
    submit.disabled = (tbody.rows.length === 0);
  }

  async function addRowFromUid(data) {
    console.log("addRowFromUid (NFC) data:", data);

    const uid = data.uid;
    if (!uid) {
      status.classList.remove("text-success", "text-muted", "text-warning");
      status.classList.add("text-danger");
      status.textContent = "Response without valid UID.";
      return;
    }

    if (addedUids.has(uid)) {
      console.log("UID duplicado ignorado:", uid);
      return;
    }

    // Preguntar SIEMPRE al backend a quÃ© curso ha estado enlazada esta tarjeta
    let payload;
    try {
      const resp = await fetch("{{ url_for('assignments.bulk_return_find') }}", {
        method: "POST",
        headers: {
          "X-Requested-With": "XMLHttpRequest",
          "Content-Type": "application/json"
        },
        body: JSON.stringify({ uid: uid })
      });
      payload = await resp.json();
    } catch (e) {
      console.error("Error fetch bulk_return_find:", e);
      status.classList.remove("text-muted", "text-success", "text-warning");
      status.classList.add("text-danger");
      status.textContent = "Error talking to server (course lookup).";
      return;
    }

    if (!payload) {
      status.classList.remove("text-success");
      status.classList.add("text-danger");
      status.textContent = "Invalid response from server.";
      return;
    }

    const info = payload.data || {};

    // AquÃ­ NO filtramos por 'status' ni 'active' ni nada en el front.
    // Mostramos lo que venga.
    const assignmentId = info.assignment_id || null;
    const courseName   = info.course_name || "Not linked";
    const endDate      = info.course_end_date || "-";
    const overdueDays  = info.overdue_days || 0;

    const deviceName =
      info.device_name ||
      data.device_name ||
      ("Device for UID " + uid);

    const deviceId = info.device_id || data.device_id || "";

    addedUids.add(uid);

    const rowIndex = tbody.rows.length + 1;
    const tr = document.createElement("tr");

    const canReturn = !!assignmentId;  // si no hay assignment_id, se muestra igual pero no se devolverÃ¡ nada

    tr.innerHTML = `
      <td>${rowIndex}</td>
      <td>${deviceName}</td>
      <td>${uid}</td>
      <td>${courseName}</td>
      <td>${endDate}</td>
      <td>${overdueDays}</td>
      <td class="text-end">
        ${canReturn ? `
          <input type="checkbox"
                 class="form-check-input me-2"
                 name="assignment_ids"
                 value="${assignmentId}"
                 checked>
        ` : `
          <span class="text-muted me-2">No assignment</span>
        `}
        <button type="button"
                class="btn btn-sm btn-outline-danger btn-remove-device">
          Remove
        </button>
        <input type="hidden" name="uids[]" value="${uid}">
        ${deviceId ? `<input type="hidden" name="device_ids[]" value="${deviceId}">` : ""}
      </td>
    `;

    tbody.appendChild(tr);
    refreshSubmitState();

    status.classList.remove("text-danger", "text-muted", "text-warning");
    status.classList.add("text-success");
    status.textContent = "Card added: " + uid + " (course: " + courseName + ")";
  }

  // DelegaciÃ³n para los botones "Remove"
  tbody.addEventListener("click", function (ev) {
    if (!ev.target.classList.contains("btn-remove-device")) return;

    const tr = ev.target.closest("tr");
    if (!tr) return;

    const uidInput = tr.querySelector('input[name="uids[]"]');
    if (uidInput) {
      addedUids.delete(uidInput.value);
    }

    tr.remove();

    // Renumerar filas
    Array.from(tbody.rows).forEach((row, idx) => {
      row.cells[0].textContent = idx + 1;
    });

    refreshSubmitState();
  });

  async function readOnce() {
    if (!polling) return;

    icon.textContent = "âŒ›";
    status.classList.remove("text-danger");
    if (!status.classList.contains("text-success")) {
      status.classList.add("text-muted");
      status.textContent = "Waiting for cardâ€¦";
    }

    try {
      const resp = await fetch("{{ url_for('users.read_uid_once') }}", {
        method: "POST",
        headers: {
          "X-Requested-With": "XMLHttpRequest",
          "Content-Type": "application/json"
        },
        body: JSON.stringify({})
      });

      const data = await resp.json().catch(() => ({}));
      console.log("Respuesta NFC assignments RETURN:", data);

      if (data.success) {
        await addRowFromUid(data);
      } else {
        if (data.reason && data.reason !== "no_card") {
          status.classList.remove("text-muted", "text-success", "text-warning");
          status.classList.add("text-danger");

          if (data.reason === "nfc_unavailable") {
            status.textContent = "NFC not available on server.";
          } else if (data.reason === "reader_error") {
            status.textContent = data.error || "NFC reader error.";
          } else {
            status.textContent = data.error || "Could not read card.";
          }
        }
      }
    } catch (e) {
      console.error("Error fetch NFC (assignments RETURN):", e);
      status.classList.remove("text-muted", "text-success", "text-warning");
      status.classList.add("text-danger");
      status.textContent = "Communication error with server.";
    } finally {
      icon.textContent = "ðŸ“¡";
      if (polling) {
        setTimeout(readOnce, POLL_DELAY_MS);
      }
    }
  }

  // Arrancamos el bucle automÃ¡ticamente
  readOnce();
  refreshSubmitState();
});
</script>
{% endblock %}
