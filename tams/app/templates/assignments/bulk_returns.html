{% extends "base.html" %}

{% block content %}
<div class="container py-3">
  <h4 class="mb-3">Return devices</h4>

  <form method="post" id="bulk-return-form">
    {% if csrf_token is defined %}
      {{ csrf_token() }}
    {% endif %}

    <!-- BotÃ³n NFC + estado -->
    <div class="mb-3 d-flex align-items-center gap-3">
      <button type="button" id="btn-read-uid" class="btn btn-primary btn-sm" disabled>
        <span id="btn-read-icon">ðŸ“¡</span>
        <span>Reading cardsâ€¦</span>
      </button>
      <small id="uid-status" class="text-muted">
        Approach cards to the reader. New cards will be added automatically.
      </small>
    </div>

    <!-- Input manual (UID / Name) -->
    <div class="mb-3">
      <label class="form-label">Or enter card identifier (UID / Name)</label>
      <input
        type="text"
        id="card-query-input"
        class="form-control"
        placeholder="Type UID or card nameâ€¦"
        autocomplete="off"
      >
      <div class="form-text" id="card-query-status">
        Press Enter to add (or wait a moment after typing).
      </div>
    </div>

    <!-- Tabla de devices -->
    <div class="table-responsive mb-3">
      <table class="table table-sm align-middle mb-0">
        <thead>
          <tr>
            <th>#</th>
            <th>Device name</th>
            <th>UID</th>
            <th>Course</th>
            <th>End date</th>
            <th>Overdue days</th>
            <th class="text-end">Actions</th>
          </tr>
        </thead>
        <tbody id="devices-table-body">
          <!-- Filas generadas por JS -->
        </tbody>
      </table>
    </div>

    <div class="d-flex justify-content-between mt-3">
      <a href="{{ url_for('main.index') }}" class="btn btn-secondary">
        Cancel
      </a>
      <button type="submit" class="btn btn-primary" id="submit-btn">
        Return selected cards
      </button>
    </div>
  </form>
</div>

<script>
document.addEventListener("DOMContentLoaded", function () {
  console.log("assignments bulk RETURN NFC JS cargado (auto-poll) + manual lookup");

  const btn    = document.getElementById("btn-read-uid");
  const status = document.getElementById("uid-status");
  const icon   = document.getElementById("btn-read-icon");
  const tbody  = document.getElementById("devices-table-body");
  const submit = document.getElementById("submit-btn");

  const qInput  = document.getElementById("card-query-input");
  const qStatus = document.getElementById("card-query-status");

  if (!btn || !status || !icon || !tbody || !submit || !qInput || !qStatus) {
    console.warn("Elementos (assignments bulk return) no encontrados en el DOM");
    return;
  }

  // Para evitar duplicados de UID
  const addedUids = new Set();
  let polling = true;
  const POLL_DELAY_MS = 1000;

  // Local agent endpoint (runs on each client PC)
  const AGENT_UID_URL = "http://127.0.0.1:8765/uid";

  function setQStatus(text, cls) {
    qStatus.className = "form-text";
    if (cls) qStatus.classList.add(cls);
    qStatus.textContent = text;
  }

  function refreshSubmitState() {
    submit.disabled = (tbody.rows.length === 0);
  }

  function renumber() {
    Array.from(tbody.rows).forEach((row, idx) => {
      row.cells[0].textContent = idx + 1;
    });
  }

  function escapeHtml(s) {
    return String(s ?? "")
      .replaceAll("&", "&amp;")
      .replaceAll("<", "&lt;")
      .replaceAll(">", "&gt;")
      .replaceAll('"', "&quot;")
      .replaceAll("'", "&#039;");
  }

  function summarizeMatches(matches) {
    const top = (matches || []).slice(0, 3).map(m => {
      const name = m.name || ("#" + m.id);
      const uid = m.uid ? ("UID " + m.uid) : "";
      return [name, uid].filter(Boolean).join(" | ");
    });
    const more = (matches && matches.length > 3) ? ` (+${matches.length - 3} more)` : "";
    return top.join(" / ") + more;
  }

  async function addRowFromUid(data) {
    console.log("addRowFromUid (UID resolved) data:", data);

    const uid = (data.uid || "").trim();
    if (!uid) {
      status.classList.remove("text-success", "text-muted", "text-warning");
      status.classList.add("text-danger");
      status.textContent = "Response without valid UID.";
      return;
    }

    if (addedUids.has(uid)) {
      console.log("UID duplicado ignorado:", uid);
      return;
    }

    // Preguntar SIEMPRE al backend a quÃ© curso ha estado enlazada esta tarjeta
    let payload;
    try {
      const resp = await fetch("{{ url_for('assignments.bulk_return_find') }}", {
        method: "POST",
        headers: {
          "X-Requested-With": "XMLHttpRequest",
          "Content-Type": "application/json"
        },
        body: JSON.stringify({ uid: uid })
      });
      payload = await resp.json();
    } catch (e) {
      console.error("Error fetch bulk_return_find:", e);
      status.classList.remove("text-muted", "text-success", "text-warning");
      status.classList.add("text-danger");
      status.textContent = "Error talking to server (course lookup).";
      return;
    }

    if (!payload) {
      status.classList.remove("text-success");
      status.classList.add("text-danger");
      status.textContent = "Invalid response from server.";
      return;
    }

    const info = payload.data || {};

    const assignmentId = info.assignment_id || null;
    const courseName   = info.course_name || "Not linked";
    const endDate      = info.course_end_date || "-";
    const overdueDays  = info.overdue_days || 0;

    const deviceName =
      info.device_name ||
      data.device_name ||
      ("Device for UID " + uid);

    const deviceId = info.device_id || data.device_id || "";

    addedUids.add(uid);

    const tr = document.createElement("tr");
    const canReturn = !!assignmentId;

    tr.dataset.uid = uid;

    tr.innerHTML = `
      <td>0</td>
      <td>${escapeHtml(deviceName)}</td>
      <td><span class="font-monospace">${escapeHtml(uid)}</span></td>
      <td>${escapeHtml(courseName)}</td>
      <td>${escapeHtml(endDate)}</td>
      <td>${escapeHtml(overdueDays)}</td>
      <td class="text-end">
        ${canReturn ? `
          <input type="checkbox"
                 class="form-check-input me-2 row-selector"
                 name="assignment_ids"
                 value="${escapeHtml(assignmentId)}"
                 checked>
        ` : `
          <span class="text-muted me-2">No assignment</span>
        `}
        <button type="button"
                class="btn btn-sm btn-outline-danger btn-remove-device">
          Remove
        </button>
        <input type="hidden" name="uids[]" value="${escapeHtml(uid)}">
        ${deviceId ? `<input type="hidden" name="device_ids[]" value="${escapeHtml(deviceId)}">` : ""}
      </td>
    `;

    tbody.appendChild(tr);
    renumber();
    refreshSubmitState();

    status.classList.remove("text-danger", "text-muted", "text-warning");
    status.classList.add("text-success");
    status.textContent = "Card added: " + uid + " (course: " + courseName + ")";
  }

  // DelegaciÃ³n para los botones "Remove"
  tbody.addEventListener("click", function (ev) {
    if (!ev.target.classList.contains("btn-remove-device")) return;

    const tr = ev.target.closest("tr");
    if (!tr) return;

    const uid = tr.dataset.uid || "";
    if (uid) addedUids.delete(uid);

    tr.remove();
    renumber();
    refreshSubmitState();
  });

  // --- Manual lookup (UID / Name) -> api_card_lookup -> reuse addRowFromUid ---
  const pendingQueries = new Set();
  let debounceTimer = null;

  async function lookupCard(q) {
    q = (q || "").trim();
    if (!q) return;

    if (pendingQueries.has(q)) return;
    pendingQueries.add(q);

    setQStatus("Looking up identifierâ€¦", "text-muted");

    try {
      const resp = await fetch("{{ url_for('courses.api_card_lookup') }}", {
        method: "POST",
        headers: { "Content-Type": "application/json", "X-Requested-With": "XMLHttpRequest" },
        body: JSON.stringify({ q })
      });

      const data = await resp.json().catch(() => ({}));

      if (!resp.ok || !data.success) {
        if (resp.status === 409 && data.matches && Array.isArray(data.matches) && data.matches.length) {
          setQStatus("Multiple matches. Be more specific: " + summarizeMatches(data.matches), "text-warning");
          return;
        }
        setQStatus(data.error || "Not found.", "text-danger");
        return;
      }

      const card = data.card || data.device;
      if (!card || !card.uid) {
        setQStatus("Lookup returned no UID for that card.", "text-danger");
        return;
      }

      // Reutilizamos tu pipeline (bulk_return_find) pasando un objeto compatible
      await addRowFromUid({
        uid: card.uid,
        device_id: card.id,
        device_name: card.name || ("Card #" + card.id),
      });

      setQStatus("Added: " + (card.uid || card.name || ("#" + card.id)), "text-success");
    } catch (e) {
      console.error(e);
      setQStatus("Server communication error.", "text-danger");
    } finally {
      pendingQueries.delete(q);
    }
  }

  function triggerManual() {
    const raw = (qInput.value || "").trim();
    if (!raw) return;
    qInput.value = "";
    qInput.focus();
    lookupCard(raw);
  }

  qInput.addEventListener("keydown", function (e) {
    if (e.key === "Enter") {
      e.preventDefault();
      if (debounceTimer) clearTimeout(debounceTimer);
      debounceTimer = null;
      triggerManual();
    }
  });

  qInput.addEventListener("input", function () {
    if (debounceTimer) clearTimeout(debounceTimer);
    debounceTimer = setTimeout(() => {
      debounceTimer = null;
      const v = (qInput.value || "").trim();
      if (v.length < 3) return;
      triggerManual();
    }, 500);
  });

  // Checkbox change -> enable/disable submit based on selection
  tbody.addEventListener("change", function () {
    // si quieres: submit disabled si no hay ningÃºn checkbox marcado
    // ahora lo dejamos como estaba (submit depende de filas), pero aquÃ­ puedes endurecerlo
  });

  async function readOnce() {
    if (!polling) return;

    icon.textContent = "âŒ›";
    status.classList.remove("text-danger");
    if (!status.classList.contains("text-success")) {
      status.classList.add("text-muted");
      status.textContent = "Waiting for cardâ€¦";
    }

    try {
      // 1) Read from local agent
      const aResp = await fetch(AGENT_UID_URL, { method: "GET", cache: "no-store" });
      const aData = await aResp.json().catch(() => ({}));

      if (!aData || aData.success !== true || !aData.uid) {
        if (aData && aData.reason === "no_card") {
          // silent
        } else if (aData && aData.reason === "agent_error") {
          status.classList.remove("text-muted", "text-success", "text-warning");
          status.classList.add("text-danger");
          status.textContent = aData.error || "NFC agent error.";
        }
        return;
      }

      // 2) Send UID to server (normalizes and keeps response shape)
      const resp = await fetch("{{ url_for('users.read_uid_once') }}", {
        method: "POST",
        headers: {
          "X-Requested-With": "XMLHttpRequest",
          "Content-Type": "application/json"
        },
        body: JSON.stringify({ uid: aData.uid })
      });

      const data = await resp.json().catch(() => ({}));
      console.log("Respuesta NFC assignments RETURN:", data);

      if (data.success) {
        await addRowFromUid(data);
      } else {
        status.classList.remove("text-muted", "text-success", "text-warning");
        status.classList.add("text-danger");
        status.textContent = data.error || "Could not read card.";
      }
    } catch (e) {
      console.error("Error fetch NFC (assignments RETURN):", e);
      status.classList.remove("text-muted", "text-success", "text-warning");
      status.classList.add("text-danger");
      status.textContent = "Communication error with server.";
    } finally {
      icon.textContent = "ðŸ“¡";
      if (polling) {
        setTimeout(readOnce, POLL_DELAY_MS);
      }
    }
  }

  // Arrancamos el bucle automÃ¡ticamente
  readOnce();
  refreshSubmitState();
});
</script>
{% endblock %}
