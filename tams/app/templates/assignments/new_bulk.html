{% extends "base.html" %}

{% block content %}
<div class="container py-3">
  <h4 class="mb-3">Associate devices to course</h4>

  <form method="post" id="bulk-assign-form">
    {% if csrf_token is defined %}
      {{ csrf_token() }}
    {% endif %}

    <!-- Curso -->
    <div class="mb-3">
      <label class="form-label">Course</label>
      <input type="text" class="form-control"
             value="{{ course.course or course.name or ('Course #' ~ course.id) }}"
             readonly>
      <input type="hidden" name="course_id" value="{{ course.id }}">
    </div>

    <!-- BotÃ³n NFC + estado -->
    <div class="mb-3 d-flex align-items-center gap-3">
      <button type="button" id="btn-read-uid" class="btn btn-primary btn-sm" disabled>
        <span id="btn-read-icon">ðŸ“¡</span>
        <span>Reading cardsâ€¦</span>
      </button>
      <small id="uid-status" class="text-muted">
        Approach cards to the reader. New cards will be added automatically.
      </small>
    </div>

    <!-- Input manual (UID / barcode / name) -->
    <div class="mb-3">
      <label class="form-label">Or scan / enter card identifier (UID / Barcode / Name)</label>
      <div class="d-flex gap-2">
        <input
          type="text"
          id="card-query-input"
          class="form-control"
          placeholder="Type UID or card name and press enterâ€¦"
          autocomplete="off"
        >
      </div>
      <small id="card-query-status" class="text-muted">
        Press Enter to add. (Also works with typing, after a short delay.)
      </small>
    </div>

    <!-- Tabla de devices -->
    <div class="table-responsive mb-3">
      <table class="table table-sm align-middle mb-0">
        <thead>
          <tr>
            <th style="width:40px;">#</th>
            <th>Device name</th>
            <th style="width:220px;">UID</th>
            <th style="width:220px;">Barcode</th>
            <th style="width:120px;" class="text-center">Temporary</th>
            <th class="text-end" style="width:220px;">Actions</th>
          </tr>
        </thead>
        <tbody id="devices-table-body">
          <!-- Filas generadas por JS -->
        </tbody>
      </table>
    </div>

    <div class="d-flex justify-content-between mt-3">
      <a href="{{ url_for('main.index') }}" class="btn btn-secondary">
        Cancel
      </a>
      <button type="submit" class="btn btn-primary" id="submit-btn">
        Save selected cards
      </button>
    </div>
  </form>
</div>

<script>
document.addEventListener("DOMContentLoaded", function () {
  console.log("assignments bulk NFC JS cargado (auto-poll) + manual lookup");

  const btn    = document.getElementById("btn-read-uid");
  const status = document.getElementById("uid-status");
  const icon   = document.getElementById("btn-read-icon");
  const tbody  = document.getElementById("devices-table-body");
  const submit = document.getElementById("submit-btn");
  const form   = document.getElementById("bulk-assign-form");

  const qInput  = document.getElementById("card-query-input");
  const qStatus = document.getElementById("card-query-status");

  if (!btn || !status || !icon || !tbody || !submit || !form || !qInput || !qStatus) {
    console.warn("Elementos (assignments bulk) no encontrados en el DOM");
    return;
  }

  // Dedupe robusto: por device_id (siempre que lo tengamos)
  const addedDeviceIds = new Set();
  // fallback por UID si viene sin device_id (no deberÃ­a, pero humans)
  const addedUids = new Set();

  let polling = true;
  const POLL_DELAY_MS = 1000;

  // Local agent endpoint (runs on each client PC)
  const AGENT_UID_URL = "http://127.0.0.1:8765/uid";

  function refreshSubmitState() {
    const anyChecked = !!tbody.querySelector('input.row-selector:checked');
    submit.disabled = !anyChecked;
  }

  function renumber() {
    Array.from(tbody.rows).forEach((row, idx) => {
      row.cells[0].textContent = idx + 1;
    });
  }

  function escapeHtml(s) {
    return String(s ?? "")
      .replaceAll("&", "&amp;")
      .replaceAll("<", "&lt;")
      .replaceAll(">", "&gt;")
      .replaceAll('"', "&quot;")
      .replaceAll("'", "&#039;");
  }

  function setQStatus(text, cls) {
    qStatus.className = "text-muted";
    if (cls) qStatus.classList.add(cls);
    qStatus.textContent = text;
  }

function addRowUnified({ device_id, device_name, uid, barcode }) {

  const did = device_id ? String(device_id) : "";
  const u = (uid || "").trim();

  if (did && addedDeviceIds.has(did)) return;
  if (!did && u && addedUids.has(u)) return;

  if (did) addedDeviceIds.add(did);
  if (u) addedUids.add(u);

  const tr = document.createElement("tr");

  tr.innerHTML = `
    <td>0</td>
    <td>${escapeHtml(device_name || "Device")}</td>
    <td><span class="font-monospace">${escapeHtml(u || "-")}</span></td>
    <td><span class="font-monospace">${escapeHtml(barcode || "-")}</span></td>

    <td class="text-center">
      <input type="checkbox" class="form-check-input temp-flag">
      <input type="hidden" name="is_temporary_flags[]" value="0">
    </td>

    <td class="text-end">
      <input type="checkbox" class="form-check-input row-selector me-2" checked>
      <button type="button" class="btn btn-sm btn-outline-danger btn-remove-device">
        Remove
      </button>

      <input type="hidden" name="uids[]" value="${escapeHtml(u)}">
      ${did ? `<input type="hidden" name="device_ids[]" value="${escapeHtml(did)}">` : ""}
    </td>
  `;

  tbody.appendChild(tr);
  renumber();
  refreshSubmitState();
}
  function addRowFromUid(data) {
    const uid = (data.uid || "").trim();
    if (!uid) {
      status.classList.remove("text-success", "text-muted", "text-warning");
      status.classList.add("text-danger");
      status.textContent = "Response without valid UID.";
      return;
    }

    // Backend users.read_uid_once ya intenta resolver device
    addRowUnified({
      device_id: data.device_id || "",
      device_name: data.device_name || ("Device for UID " + uid),
      uid: uid,
      barcode: data.barcode || ""  // si tu backend no lo manda, queda "-"
    });

    status.classList.remove("text-danger", "text-muted", "text-warning");
    status.classList.add("text-success");
    status.textContent = "Card added: " + uid;
  }

  // Checkbox select
tbody.addEventListener("change", function (ev) {

  if (ev.target.classList.contains("row-selector")) {
    refreshSubmitState();
  }

  if (ev.target.classList.contains("temp-flag")) {
    const tr = ev.target.closest("tr");
    const hidden = tr.querySelector('input[name="is_temporary_flags[]"]');
    hidden.value = ev.target.checked ? "1" : "0";
  }
});

  // Antes de submit: deshabilitar inputs de filas no seleccionadas
  form.addEventListener("submit", function () {
    const rows = tbody.querySelectorAll("tr");
    rows.forEach((row) => {
      const checkbox = row.querySelector("input.row-selector");
      const inputs = row.querySelectorAll('input[name="uids[]"], input[name="device_ids[]"]');
      const disabled = checkbox && !checkbox.checked;
      inputs.forEach((inp) => inp.disabled = disabled);
    });
  });

  // Remove row
  tbody.addEventListener("click", function (ev) {
    if (!ev.target.classList.contains("btn-remove-device")) return;

    const tr = ev.target.closest("tr");
    if (!tr) return;

    const did = tr.dataset.deviceId || "";
    const u = tr.dataset.uid || "";

    if (did) addedDeviceIds.delete(did);
    if (u) addedUids.delete(u);

    tr.remove();
    renumber();
    refreshSubmitState();
  });

  // --- Manual lookup (UID / barcode / name) ---
  const pendingQueries = new Set();
  let debounceTimer = null;

  async function lookupCardQuery(q) {
    q = (q || "").trim();
    if (!q) return;

    if (pendingQueries.has(q)) return;
    pendingQueries.add(q);

    setQStatus("Looking up identifierâ€¦", "text-muted");

    try {
      const resp = await fetch("{{ url_for('courses.api_card_lookup') }}", {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
          "X-Requested-With": "XMLHttpRequest"
        },
        body: JSON.stringify({ q })
      });

      const data = await resp.json().catch(() => ({}));

      if (!resp.ok || !data.success) {
        if (resp.status === 409 && data.matches && Array.isArray(data.matches) && data.matches.length) {
          // Mostramos un resumen corto para que el humano sea mÃ¡s especÃ­fico
          const top = data.matches.slice(0, 3).map(m => {
            const name = m.name || ("#" + m.id);
            const uid = m.uid ? ("UID " + m.uid) : "";
            const bar = m.barcode ? ("BAR " + m.barcode) : "";
            return [name, uid, bar].filter(Boolean).join(" | ");
          }).join(" / ");
          const more = data.matches.length > 3 ? ` (+${data.matches.length - 3} more)` : "";
          setQStatus("Multiple matches. Be more specific: " + top + more, "text-warning");
          return;
        }

        setQStatus(data.error || "Not found.", "text-danger");
        return;
      }

      // Esperamos payload: { success:true, card:{id,name,uid,barcode,...}, active_loan:... }
      const card = data.card || data.device || null;
      if (!card) {
        setQStatus("Lookup returned no card/device.", "text-danger");
        return;
      }

      addRowUnified({
        device_id: card.id,
        device_name: card.name || ("Device #" + card.id),
        uid: card.uid || "",
        barcode: card.barcode || ""
      });

      setQStatus("Card added: " + (card.uid || card.barcode || card.name || ("#" + card.id)), "text-success");
    } catch (e) {
      console.error(e);
      setQStatus("Server communication error.", "text-danger");
    } finally {
      pendingQueries.delete(q);
    }
  }

  function triggerFromManualInput() {
    const raw = (qInput.value || "").trim();
    if (!raw) return;
    qInput.value = "";
    qInput.focus();
    lookupCardQuery(raw);
  }

  qInput.addEventListener("keydown", function (e) {
    if (e.key === "Enter") {
      e.preventDefault();
      if (debounceTimer) clearTimeout(debounceTimer);
      debounceTimer = null;
      triggerFromManualInput();
    }
  });

  qInput.addEventListener("input", function () {
    if (debounceTimer) clearTimeout(debounceTimer);
    debounceTimer = setTimeout(() => {
      debounceTimer = null;
      const v = (qInput.value || "").trim();
      if (v.length < 3) return;
      triggerFromManualInput();
    }, 400);
  });

  // --- NFC loop ---
  async function readOnce() {
    if (!polling) return;

    icon.textContent = "âŒ›";
    status.classList.remove("text-danger");
    if (!status.classList.contains("text-success")) {
      status.classList.add("text-muted");
      status.textContent = "Waiting for cardâ€¦";
    }

    try {
      // 1) Read from local agent
      const aResp = await fetch(AGENT_UID_URL, { method: "GET", cache: "no-store" });
      const aData = await aResp.json().catch(() => ({}));

      if (!aData || aData.success !== true || !aData.uid) {
        if (aData && aData.reason === "no_card") {
          // silent
        } else if (aData && aData.reason === "agent_error") {
          status.classList.remove("text-muted", "text-success", "text-warning");
          status.classList.add("text-danger");
          status.textContent = aData.error || "NFC agent error.";
        }
        return;
      }

      // 2) Send UID to server (normalize/resolve)
      const resp = await fetch("{{ url_for('users.read_uid_once') }}", {
        method: "POST",
        headers: {
          "X-Requested-With": "XMLHttpRequest",
          "Content-Type": "application/json"
        },
        body: JSON.stringify({ uid: aData.uid })
      });

      const data = await resp.json().catch(() => ({}));
      console.log("Respuesta NFC assignments:", data);

      if (data.success) {
        addRowFromUid(data);
      } else {
        if (data.reason && data.reason !== "no_card") {
          status.classList.remove("text-muted", "text-success", "text-warning");
          status.classList.add("text-danger");

          if (data.reason === "nfc_unavailable") {
            status.textContent = "NFC not available on server.";
          } else if (data.reason === "reader_error") {
            status.textContent = data.error || "NFC reader error.";
          } else {
            status.textContent = data.error || "Could not read card.";
          }
        }
      }
    } catch (e) {
      console.error("Error fetch NFC (assignments):", e);
      status.classList.remove("text-muted", "text-success", "text-warning");
      status.classList.add("text-danger");
      status.textContent = "Communication error with server.";
    } finally {
      icon.textContent = "ðŸ“¡";
      if (polling) {
        setTimeout(readOnce, POLL_DELAY_MS);
      }
    }
  }

  // Arrancamos el bucle automÃ¡ticamente
  readOnce();
  refreshSubmitState();
});
</script>
{% endblock %}
